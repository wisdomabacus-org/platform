import { useState, useEffect } from 'react';
import { Button } from '@/shared/components/ui/button';
import { Input } from '@/shared/components/ui/input';
import { Label } from '@/shared/components/ui/label';
import { Select, SelectContent, SelectItem, SelectTrigger, SelectValue } from '@/shared/components/ui/select';
import { OperatorType, Question } from '../../types/question-bank.types';
import { generateOptions } from '../../utils/question-generator';
import { Plus, Trash2 } from 'lucide-react';
import { Separator } from '@/shared/components/ui/separator';

interface Props {
    onSave: (question: Partial<Question>) => void;
    onCancel: () => void;
}

export function ManualQuestionForm({ onSave, onCancel }: Props) {
    const [operator, setOperator] = useState<OperatorType>('addition');
    const [operands, setOperands] = useState<string[]>(['0', '0']); // Use strings for input handling
    const [answer, setAnswer] = useState<number>(0);

    // Auto-calculate answer whenever operands or operator changes
    useEffect(() => {
        const numbers = operands.map(n => parseFloat(n) || 0);
        let res = 0;

        // Basic calculation logic matching the generator
        if (numbers.length > 0) {
            if (operator === 'multiplication') {
                res = numbers.reduce((a, b) => a * b, 1);
            } else if (operator === 'division') {
                res = numbers.length >= 2 && numbers[1] !== 0 ? numbers[0] / numbers[1] : 0;
                // Round to 2 decimals for division if needed, or keep simple
                res = Math.round(res * 100) / 100;
            } else {
                // Mixed / Addition / Subtraction
                // For mixed, it's just summing them up (negatives handle subtraction)
                // But if specific operators are enforced, we might need more logic. 
                // For now, assume 'addition' sums all, 'subtraction' subtracts from first? 
                // actually generator uses simple accumulation. 
                res = numbers.reduce((acc, curr, idx) => {
                    if (operator === 'addition') return acc + curr;
                    if (operator === 'subtraction') return idx === 0 ? curr : acc - curr;
                    return acc + curr; // Mixed usually implies explicit signs in operands
                }, 0);

                // If mixed, users should enter negative numbers manually for subtraction.
                if (operator === 'mixed') {
                    res = numbers.reduce((a, b) => a + b, 0);
                }
            }
        }
        setAnswer(res);
    }, [operands, operator]);

    const handleOperandChange = (index: number, value: string) => {
        const newOperands = [...operands];
        newOperands[index] = value;
        setOperands(newOperands);
    };

    const addOperand = () => setOperands([...operands, '0']);
    const removeOperand = (index: number) => {
        if (operands.length <= 2) return;
        setOperands(operands.filter((_, i) => i !== index));
    };

    const handleSave = () => {
        const numbers = operands.map(n => parseFloat(n) || 0);
        const options = generateOptions(answer, 20); // 20% randomness

        const question: Partial<Question> = {
            type: 'abacus', // Default to abacus type
            operatorType: operator,
            operations: numbers,
            correctAnswer: answer,
            options: options,
            digits: Math.max(...numbers).toString().length,
            rowsCount: numbers.length,
            isAutoGenerated: false,
        };
        onSave(question);
    };

    const isMathOp = ['multiplication', 'division'].includes(operator);

    // Correction for Multiplication/Division: usually 2 operands
    useEffect(() => {
        if (isMathOp && operands.length !== 2) {
            setOperands(operands.slice(0, 2));
            if (operands.length < 2) setOperands(prev => [...prev, '0']);
        }
    }, [operator, isMathOp, operands]);

    return (
        <div className="space-y-4 py-2">
            <div className="grid grid-cols-2 gap-4">
                <div className="space-y-2">
                    <Label>Operator</Label>
                    <Select value={operator} onValueChange={(v: OperatorType) => setOperator(v)}>
                        <SelectTrigger>
                            <SelectValue />
                        </SelectTrigger>
                        <SelectContent>
                            <SelectItem value="addition">Addition</SelectItem>
                            <SelectItem value="subtraction">Subtraction</SelectItem>
                            <SelectItem value="mixed">Mixed</SelectItem>
                            <SelectItem value="multiplication">Multiplication</SelectItem>
                            <SelectItem value="division">Division</SelectItem>
                        </SelectContent>
                    </Select>
                </div>

                <div className="flex flex-col justify-end pb-2">
                    <div className="text-right text-sm text-muted-foreground">
                        Calculated Answer: <span className="font-bold text-primary text-lg ml-2">{answer}</span>
                    </div>
                </div>
            </div>

            <Separator />

            <div className="space-y-3">
                <div className="flex items-center justify-between">
                    <Label>Operands (Numbers)</Label>
                    {!isMathOp && (
                        <Button variant="ghost" size="sm" onClick={addOperand} className="h-6 gap-1 text-xs">
                            <Plus className="h-3 w-3" /> Add Row
                        </Button>
                    )}
                </div>

                <div className="grid grid-cols-2 gap-3 max-h-[300px] overflow-y-auto p-1">
                    {operands.map((op, idx) => (
                        <div key={idx} className="flex items-center gap-2">
                            <span className="text-xs text-muted-foreground w-4">{idx + 1}.</span>
                            <Input
                                value={op}
                                onChange={(e) => handleOperandChange(idx, e.target.value)}
                                type="number"
                                className="h-8"
                            />
                            {!isMathOp && operands.length > 2 && (
                                <Button
                                    variant="ghost"
                                    size="icon"
                                    className="h-8 w-8 text-muted-foreground hover:text-destructive"
                                    onClick={() => removeOperand(idx)}
                                >
                                    <Trash2 className="h-3 w-3" />
                                </Button>
                            )}
                        </div>
                    ))}
                </div>
            </div>

            <div className="flex justify-end gap-2 pt-4">
                <Button variant="outline" onClick={onCancel}>Cancel</Button>
                <Button onClick={handleSave}>Add Question</Button>
            </div>
        </div>
    );
}
