// supabase/functions/_shared/supabase.ts
// Shared Supabase client for Edge Functions

import { createClient, SupabaseClient } from "npm:@supabase/supabase-js@2";

// Types for user from JWT
export interface AuthUser {
    id: string;
    email?: string;
    phone?: string;
    role?: string;
}

// Types for session-based auth
export interface SessionAuthResult {
    user: AuthUser;
    session: {
        id: string;
        session_token: string;
        user_id: string;
        exam_type: string;
        exam_id: string;
        submission_id: string;
        status: string;
        start_time: string;
        end_time: string;
        duration_minutes: number;
        answers: Record<string, unknown>;
    };
}

/**
 * Create a Supabase client with service role (full access)
 * Use this for operations that need to bypass RLS
 */
export function createServiceClient(): SupabaseClient {
    return createClient(
        Deno.env.get("SUPABASE_URL")!,
        Deno.env.get("SUPABASE_SERVICE_ROLE_KEY")!,
        {
            auth: {
                autoRefreshToken: false,
                persistSession: false,
            },
        }
    );
}

/**
 * Create a Supabase client with the user's JWT
 * Use this for operations that should respect RLS
 */
export function createUserClient(accessToken: string): SupabaseClient {
    return createClient(
        Deno.env.get("SUPABASE_URL")!,
        Deno.env.get("SUPABASE_ANON_KEY")!,
        {
            global: {
                headers: {
                    Authorization: `Bearer ${accessToken}`,
                },
            },
            auth: {
                autoRefreshToken: false,
                persistSession: false,
            },
        }
    );
}

/**
 * Get the authenticated user from the request
 * Returns null if not authenticated
 */
export async function getAuthUser(req: Request): Promise<AuthUser | null> {
    const authHeader = req.headers.get("Authorization");
    if (!authHeader?.startsWith("Bearer ")) {
        return null;
    }

    const token = authHeader.replace("Bearer ", "");
    const supabase = createServiceClient();

    const {
        data: { user },
        error,
    } = await supabase.auth.getUser(token);

    if (error || !user) {
        return null;
    }

    return {
        id: user.id,
        email: user.email,
        phone: user.phone,
        role: user.role,
    };
}

/**
 * Require authentication - throws if not authenticated
 */
export async function requireAuth(req: Request): Promise<AuthUser> {
    const user = await getAuthUser(req);
    if (!user) {
        throw new Error("Unauthorized");
    }
    return user;
}

/**
 * Authenticate via session token (for exam portal)
 * This is used when the exam portal can't use JWT auth (cross-origin)
 * The session token is securely generated by exam-start (which requires JWT auth)
 * 
 * @param sessionToken - The exam session token from exam-start
 * @returns SessionAuthResult with user and session data
 */
export async function authenticateBySessionToken(
    sessionToken: string
): Promise<SessionAuthResult> {
    if (!sessionToken) {
        throw new Error("Session token is required");
    }

    const supabase = createServiceClient();

    // Get session by token
    const { data: session, error: sessionError } = await supabase
        .from("exam_sessions")
        .select("*")
        .eq("session_token", sessionToken)
        .single();

    if (sessionError || !session) {
        console.error("Session lookup error:", sessionError);
        throw new Error("Session not found or expired");
    }

    // Check if session is still valid
    if (session.status === "submitted") {
        throw new Error("Session already submitted");
    }

    if (session.status === "expired") {
        throw new Error("Session has expired");
    }

    // Check time-based expiration
    const now = Date.now();
    const endTime = new Date(session.end_time).getTime();
    if (now > endTime) {
        // Mark as expired
        await supabase
            .from("exam_sessions")
            .update({ status: "expired" })
            .eq("id", session.id);
        throw new Error("Session has expired");
    }

    // Create user object from session
    const user: AuthUser = {
        id: session.user_id,
    };

    return {
        user,
        session: {
            id: session.id,
            session_token: session.session_token,
            user_id: session.user_id,
            exam_type: session.exam_type,
            exam_id: session.exam_id,
            submission_id: session.submission_id,
            status: session.status,
            start_time: session.start_time,
            end_time: session.end_time,
            duration_minutes: session.duration_minutes,
            answers: session.answers || {},
        },
    };
}

/**
 * Hybrid authentication: Try JWT first, fall back to session token
 * This is useful for Edge Functions that need to work with both:
 * - Website (has JWT auth)
 * - Exam Portal (uses session token)
 * 
 * @param req - Request object (for JWT header)
 * @param sessionToken - Optional session token from request body
 * @returns AuthUser
 */
export async function authenticateRequest(
    req: Request,
    sessionToken?: string
): Promise<AuthUser> {
    // Try JWT auth first
    const jwtUser = await getAuthUser(req);
    if (jwtUser) {
        return jwtUser;
    }

    // Fall back to session token auth
    if (sessionToken) {
        const sessionAuth = await authenticateBySessionToken(sessionToken);
        return sessionAuth.user;
    }

    throw new Error("Unauthorized");
}

